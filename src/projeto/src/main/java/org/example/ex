
        // Aplica um suavização para reduzir o ruído
        Imgproc.GaussianBlur(binaryImage, binaryImage, new org.opencv.core.Size(9, 9), 2, 2);
        // Detecta círculos usando a Transformada de Hough
        Mat circles = new Mat();
        Imgproc.HoughCircles(binaryImage, circles, Imgproc.HOUGH_GRADIENT, 1.0, (double) binaryImage.rows() / 8);

        // Encontra o maior círculo
        double[] largestCircle = null;
        double maxRadius = 0;
        for (int i = 0; i < circles.cols(); i++) {
            double[] circle = circles.get(0, i);
            if (circle != null && circle.length > 2) {
                double radius = circle[2];
                if (radius > maxRadius) {
                    maxRadius = radius;
                    largestCircle = circle;
                }
            }
        }

        // Cria uma máscara onde o maior círculo destacado é branco e o resto é preto
        Mat mask = new Mat(binaryImage.rows(), binaryImage.cols(), binaryImage.type(), new org.opencv.core.Scalar(0));
        if (largestCircle != null) {
            org.opencv.core.Point center = new org.opencv.core.Point(Math.round(largestCircle[0]), Math.round(largestCircle[1]));
            int radius = (int) Math.round(largestCircle[2]);
            // Desenha o maior círculo na máscara
            Imgproc.circle(mask, center, radius, new org.opencv.core.Scalar(255), -1); // -1 preenche o círculo
            // Redimensiona a máscara para o tamanho da imagem original
            Mat resizedMask = new Mat();
            Imgproc.resize(mask, resizedMask, image.size());
            // Pinta de preto na imagem original onde a máscara é preta
            Mat result = new Mat();
            Core.bitwise_and(image, image, result, resizedMask);
            Imgcodecs.imwrite(path +"\\result\\imgResult.jpeg", result);
        }else{
            System.out.println("Imagem: " + imgName + " está fora dos padrões!");
        }